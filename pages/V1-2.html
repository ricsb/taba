<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <!--
    MODIFICATIONS
    * WebGL uglyfied
    * Todas as subpáginas reincorporadas
    -->
    <title>PeriscopeSimulator - Ricardo</title>
  </head>
  <body style="background-color: #aaccff;margin: 0px;overflow: hidden;">

    <script src="js/three/three.js"></script>
    <script src="js/loaders/MTLLoader.js"></script>
    <script src="js/loaders/OBJMTLLoader.js"></script>
    <script type="text/javascript" src="js/SpriteParticleSystem.js"></script>
    <script src="js/mixer.js"></script>
    <script id="vertShaderEnvMap" type="x-shader/x-vertex">
      attribute vec4 tangent;uniform vec2 uRepeat;uniform vec2 uOffset;varying vec3 vWorldPosition;varying vec3 vViewPosition;varying vec3 vNormal;varying vec2 vUv;varying vec3 vTangent;varying vec3 vBitangent;void main() {vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;vViewPosition = -mvPosition.xyz;vUv = uv * uRepeat + uOffset;vNormal = normalize( normalMatrix * normal );vTangent = normalize( normalMatrix * tangent.xyz );vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );gl_Position = projectionMatrix * mvPosition;}
    </script>

    <script id="fragShaderEnvMap" type="x-shader/x-fragment">
      /**
      * Third part script in this block
      */
      //
      // Description : Array and textureless GLSL 2D/3D/4D simplex
      //               noise functions.
      //      Author : Ian McEwan, Ashima Arts.
      //  Maintainer : ijm
      //     Lastmod : 20110822 (ijm)
      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
      //               Distributed under the MIT License. See LICENSE file.
      //               https://github.com/ashima/webgl-noise
      //

      vec3 mod289(vec3 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i  = floor(v + dot(v, C.yyy) );vec3 x0 =   v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy;i = mod289(i);vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0 ))+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857;vec3  ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0)*2.0 + 1.0;vec4 s1 = floor(b1)*2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;vec3 p0 = vec3(a0.xy,h.x);vec3 p1 = vec3(a0.zw,h.y);vec3 p2 = vec3(a1.xy,h.z);vec3 p3 = vec3(a1.zw,h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );}uniform samplerCube tCube;uniform sampler2D tNormal;uniform float time;uniform vec2 uOffset;uniform vec3 ambientLightColor;uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];uniform float fogNear;uniform float fogFar;uniform vec3 fogColor;uniform bool useNoisePerturbations;varying vec3 vTangent;varying vec3 vBitangent;varying vec3 vWorldPosition;varying vec3 vViewPosition;varying vec3 vNormal;varying vec2 vUv;void main(){vec3 normColor = texture2D(tNormal, vUv).xyz * 2.0 - 1.0;mat3 tsb = mat3(normalize(vTangent), normalize(vBitangent), normalize(vNormal));vec3 finalNormal = tsb * normColor;if (useNoisePerturbations) {float lowFrequency = snoise(vec3(vUv.x * 10.0, vUv.y * 100.0, time * 0.25));float highFrequency = snoise(vec3(vUv.x * 5000.0, vUv.y * 5000.0, time));lowFrequency = (lowFrequency * 2.0 - 1.0) * 0.2;highFrequency = (highFrequency * 2.0 - 1.0) * 0.05;finalNormal.x += lowFrequency + highFrequency;finalNormal.z += lowFrequency + highFrequency;}finalNormal = normalize(finalNormal);vec3 envReflection = normalize(vWorldPosition - cameraPosition);envReflection = reflect(envReflection, normColor.xzy);envReflection.y = abs(envReflection.y);vec4 reflectionColor = textureCube( tCube, envReflection);vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );vec3 dirVector = normalize( lDirection.xyz );float dirDiffuseWeight = (dot( finalNormal, dirVector ) * 0.5) + 0.5;vec3 finalColor = mix(reflectionColor.xyz, vec3(0.235, 0.337, 0.475), 0.975) * dirDiffuseWeight;float depth = gl_FragCoord.z / gl_FragCoord.w;float fogFactor = smoothstep(fogNear, fogFar, depth);finalColor = mix(finalColor, fogColor, fogFactor);gl_FragColor = vec4(finalColor, 1.0);}
    </script>

    <script type="text/javascript">

/**
 *@author ricardoSBastos
 */
(function() {
//Unbound and Empty
  var camera, camera1, camera2, camera3;
  var controles, scene, renderer, mainCanvas;
  var perOverlay, chartOverlay;
  var mesh, texture, geometry, skyMaterial, fragata, corveta;
  var TargetObj, TargetParent;
  var targetArray = new Array();
  var testMaterial;
  var uniforms;
  var normalTexture;
  var colisores = new Array();
  var telaEstadimetro;
  var canvasContainer;
  var parlatorium;
  var lastMode;
  var fazOMovimento;

// Bound
  var simTime = 0;
  var ivh = 0;
  var io1 = 180;
  var tgt1Time = 0;
  var io2 = 180;
  var tgt2Time = 0;
  var lastRenderTime = 0;
  var now = 0;
  var clock = new THREE.Clock();
  var tBearing = "000.0";
  var rBearing = "325.0";
  var distance = "00000.0";
  var stad = "";
  var sbHead = 35.0;
  var periscope = new THREE.Object3D();
  var periRotVeloc = 5;
  var estadiVeloc = 0.001;
  var deltaT = 1;
  var beaufort = Math.floor(10 * Math.random()) / 3;
  var quat = new THREE.Quaternion();
  var elevation = 0;
  var fov = 40;
  var corrida = 1;
  var zoom = "1.5x";
  var maxDist = 1000;
  var tgtHeight = 0; // altura em p�s
  var grauEstadimetro = 0;
  var tempoIndiscreto = 0;
  var loadedShips = 0;
  var subPos = new THREE.Vector3(0, 0, 0);
  var points = 50;
  var centerMsg = "";

// Booleans
  var chartSmall = true;
  var turnRight = false;
  var turnLeft = false;
  var turnUp = false;
  var turnDown = false;
  var tudoPronto = false;
  var modoEstadimetro = false;
  var mapa = true;
  var fragPos = false;
  var corvPos = false;
  var paused = false;
  var music = true;
  var avisando = false;
  var varredura = false;
  var tgt1 = false;
  var primatgt1 = true;
  var tgt2 = false;
  var primatgt2 = true;
  var gameOver = false;

// Constants
  var SCREEN_WIDTH = window.innerWidth;
  var SCREEN_HEIGHT = window.innerHeight;
  var X_UNIT = new THREE.Vector3(1, 0, 0);
  var X_UNIT_NEG = new THREE.Vector3(-1, 0, 0);
  var Y_UNIT = new THREE.Vector3(0, 1, 0);
  var Y_UNIT_NEG = new THREE.Vector3(0, -1, 0);
  var Z_UNIT = new THREE.Vector3(0, 0, 1);
  var Z_UNIT_NEG = new THREE.Vector3(0, 0, -1);
  var aps = {NAVIGATION: 1, PERISCOPE: 2, INFO: 3, LOADING: 5, GAME_OVER: 6};
  var mode = aps.LOADING;

// Images
  var carta = new Image();
  carta.src = "textures/carta.png";
  var circle = new Image();
  circle.src = "textures/circle1.png";
  var subIco = new Image();
  subIco.src = "textures/U-209icone.gif";
  var hvuIco = new Image();
  hvuIco.src = "textures/carrierIcone.gif";
  var fragIco = new Image();
  fragIco.src = "textures/carrierIcone.gif";
  var loadImg = new Image();
  loadImg.src = "textures/loadImg.png";
  var infoImg = new Image();
  infoImg.src = "textures/info.png";
  var varHor = new Image();
  varHor.src = "textures/vh.png";
  var obs1 = new Image();
  obs1.src = "textures/obs1.png";
  var obs2 = new Image();
  obs2.src = "textures/obs2.png";
  var next = new Image();
  next.src = "textures/next.png";
  var previous = new Image();
  previous.src = "textures/previous.png";
  var tutor1 = new Image();
  tutor1.src = "textures/tutor1.png";
  var tutor2 = new Image();
  tutor2.src = "textures/tutor2.png";
  var tutor3 = new Image();
  tutor3.src = "textures/tutor3.png";
  var tutor = [tutor1, tutor2, tutor3];
  var tutorIndex = 0;
  var gameOver = new Image();
  gameOver.src = "textures/gameOver.png";

// Sounds
  Mixer.init(10);
  var snd = MediaLoader.loadSound("music", "sounds/Five_Armies.wav");
  var chan1 = Mixer.play(snd, 0.0, true);

// Strings
// Coming Soon: A version in two idioms!!
  var port = ["Altura do Alvo (em P�s)", "Estad�metro",
    "Exposi��o",
  ];
  var eng = ["Target Height (feet)", "Stadimeter",
    "Exposition"
  ];
  parlatorium = eng;

  /* ************************************************** */
  /* *****************Principais.js******************** */

  function animate() {
    if (!paused || !gameOver) {
      delta = clock.getDelta();
      uniforms.time.value += delta;
      uniforms.uOffset.value.y += delta * 0.001;
      render();
    }
    requestAnimationFrame(animate);
  }

  function initLightsCamerasAndScenes() {
    camera1 = new THREE.PerspectiveCamera(fov, window.innerWidth
            / window.innerHeight, .1, 20000);
    camera1.useQuaternion = true;
    camera = camera1;
    scene = new THREE.Scene();
    //periscope.position = new THREE.Vector3(0,0,0);
    scene.add(periscope);
    periscope.add(camera1);
    var m = 1050;
    var planeGeometry = new THREE.PlaneGeometry(SCREEN_WIDTH / m, SCREEN_HEIGHT / m, 1, 1);
    finalRenderTarget = new THREE.WebGLRenderTarget(SCREEN_WIDTH, SCREEN_HEIGHT, {format: THREE.RGBFormat});
    var planeMaterial = new THREE.MeshBasicMaterial({map: finalRenderTarget,
      transparent: true, opacity: 0.3});
    telaEstadimetro = new THREE.Mesh(planeGeometry, planeMaterial);
    telaEstadimetro.position.set(0, 0, -1);
    camera1.add(telaEstadimetro);
    telaEstadimetro.visible = false;

    // 0xDFF8FD matches the skybox at the horizon
    var ambientLight = new THREE.AmbientLight(0x111111);
    var sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
    sunLight.position.y = 10.0; // overhead (easier to debug and visualize)
    scene.add(ambientLight);
    scene.add(sunLight);
    var cameraLight = new THREE.DirectionalLight(0xffffff, 0.7);
    cameraLight.position.set(0, 0, 1).normalize();
    scene.add(cameraLight);
    renderer = new THREE.WebGLRenderer({antialias: true, autoClearColor: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.autoClearColor = false;
    mainCanvas = renderer.domElement;
    mainCanvas.style.zIndex = -1;
    document.body.appendChild(mainCanvas);//renderer.domElement);
    perOverlay = new Overlay(mainCanvas, "PERISCOPE");
    if (!perOverlay.overlay)
      perOverlay.create();
    window.onkeydown = onKeyDown;
    window.onkeyup = onKeyUp;
    window.onmousedown = onMouseDown;
    window.onresize = onWindowResize;
  }

  function initMaterials() {

    // skybox material
    {
      var path = "textures/sunnysky/";
      var format = '.jpg';
      var urls = [
        path + 'px' + format, path + 'nx' + format,
        path + 'py' + format, path + 'ny' + format,
        path + 'pz' + format, path + 'nz' + format
      ];

      skyCubemap = THREE.ImageUtils.loadTextureCube(urls);

      var shader = THREE.ShaderLib["cube"];
      shader.uniforms["tCube"].value = skyCubemap;

      skyMaterial = new THREE.ShaderMaterial({
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: shader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
      });
    }

    // Water material
    {
      normalmap = THREE.ImageUtils.loadTexture("textures/normal/ocean/water-normal.png");
      normalmap.wrapS = normalmap.wrapT = THREE.RepeatWrapping;

      // Note addeding all of the lighting uniforms so that three.js will auto update the values.  
      // An easier way to do this is shown commented out below but it has a bug that destroys our normal 
      // texture (submitted to three.js).
      uniforms = {time: {type: "f", value: 1.0}, useNoisePerturbations: {type: "i", value: 1}, uRepeat: {type: "v2", value: new THREE.Vector2(5.0, 5.0)}, uOffset: {type: "v2", value: new THREE.Vector2(0.0, 0.0)}, tCube: {type: "t", value: skyCubemap}, tNormal: {type: "t", value: normalmap}, ambientLightColor: {type: "fv", value: []}, directionalLightDirection: {type: "fv", value: []}, directionalLightColor: {type: "fv", value: []}, hemisphereLightDirection: {type: "fv", value: []}, hemisphereLightSkyColor: {type: "fv", value: []}, hemisphereLightGroundColor: {type: "fv", value: []}, pointLightColor: {type: "fv", value: []}, pointLightPosition: {type: "fv", value: []}, pointLightDistance: {type: "fv1", value: []}, spotLightColor: {type: "fv", value: []}, spotLightPosition: {type: "fv", value: []}, spotLightDirection: {type: "fv", value: []}, spotLightDistance: {type: "fv1", value: []}, spotLightAngleCos: {type: "fv1", value: []}, spotLightExponent: {type: "fv1", value: []}, fogDensity: {type: "f", value: 0.00025}, fogNear: {type: "f", value: 1}, fogFar: {type: "f", value: 1000}, fogColor: {type: "c", value: new THREE.Color(0xDBF6FD)}};

      // The nicer way to add light uniforms (doesn't work correctly)
      //uniforms = THREE.UniformsUtils.merge( [uniforms, THREE.UniformsLib[ "lights" ] ]);

      testMaterial = new THREE.ShaderMaterial({uniforms: uniforms, vertexShader: document.getElementById('vertShaderEnvMap').textContent, fragmentShader: document.getElementById('fragShaderEnvMap').textContent, lights: true, transparent: true});
    }
  }

  //

  function initSkybox() {
    // The box dimension size doesn't matter that much when the camera 
    // is in the center.  Experiment with the values.
    skyboxMesh = new THREE.Mesh(new THREE.CubeGeometry(1000, 1000, 1000,
            1, 1, 1), skyMaterial);
    scene.add(skyboxMesh);
  }

  function initWater() {

    waterGeom = new THREE.PlaneGeometry(maxDist, maxDist, 100, 100);

    waterGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    waterGeom.computeFaceNormals();
    waterGeom.computeVertexNormals();
    waterGeom.computeTangents();

    mesh = new THREE.Mesh(waterGeom, testMaterial);
    mesh.position.y = -1;
    scene.add(mesh);
    colisores.push(mesh);

  }
  function initSimulation() {
    corveta = new Escolta(70, -0.5, -150, 'ccb');
    fragata = new Escolta(-200, 0, -70, 'fcg');
    corveta.load();
    fragata.load();
  }

  function initEnvironment() {
    initLightsCamerasAndScenes();
    initMaterials();
    initSkybox();
    initWater();
  }
  function waveUpdate(now) {
    var leng = waterGeom.vertices.length;
    for (var i = 0; i < leng; i++) {
      var noise = Math.round(Math.random() * leng);
      //if (i/noise==0)waterGeom.vertices[ noise ].y += 1;
      waterGeom.vertices[ i ].y = beaufort * 0.1 * Math.sin
              (i / 5 + (now * 10 + i) / 15);
    }
    mesh.geometry.verticesNeedUpdate = true;
  }

  function render() {
    now = new Date().getTime() / 1000;
    deltaT = now - lastRenderTime;
    computeTimes(deltaT);
    waveUpdate(now);
    perOverlay.draw();
    periscopeUpdate(deltaT);
    corveta.prerender(deltaT);
    fragata.prerender(deltaT);
    if (modoEstadimetro) {
      telaEstadimetro.visible = false;
      renderer.render(scene, camera1, finalRenderTarget, true);
      telaEstadimetro.visible = true;
    }
    renderer.render(scene, camera1);
    lastRenderTime = now;
  }

  /* *****************Fim Principais.js**************** */
  /* ************************************************** */



  /* ************************************************** */
  /* *****************Alvos.js************************* */

  function AlvoPai() {
    var that = this;
    this.prerender = function(dt) {
      if (!this.mesh)
        return;
      if (!this.loaded) {
        loadedShips++;
        targetArray.push(this.mesh);
        this.loaded = true;
        if (loadedShips === 2) {
          chan1.volume = 0.3;
          mode = aps.NAVIGATION;
          perOverlay.draw();
          perOverlay.avisa("There are no active contacts. All Around Search recommended", 5);
        }
      }
      var checkPos = new THREE.Vector3(this.mesh.position.x,
              this.mesh.position.y + 1, this.mesh.position.z);
      var rayDown = new THREE.Raycaster(this.mesh.position, Y_UNIT_NEG);
      var rayUp = new THREE.Raycaster(this.mesh.position, Y_UNIT);
      var collisionsDown = rayDown.intersectObjects(colisores);
      var collisionsUp = rayUp.intersectObjects(colisores);
      if (collisionsDown.length > 0) {
        this.mesh.position.setY(collisionsDown[0].point.y + 0.01);
      }
      switch (this.id) {
        case 'fcg':
          this.mesh.translateY(dt / 2);
          fragPos = this.mesh.position;
          break;
        case 'ccb':
          this.mesh.translateX(dt / 2);
          corvPos = this.mesh.position;
          break;
      }
      this.balanco(dt, this.id);
      this.caturro(dt, this.id);
    };
    this.balanco = function(dt, id) {
      if (!this.mesh || beaufort === 0 || dt > 1)
        return;
      var axis;
      var v;
      var quantum = dt * beaufort / 90;
      switch (id) {
        case 'ccb':
          axis = X_UNIT;
          v = new THREE.Vector3(this.fator1 * quantum, 0, 0);
          break;
        case 'fcg':
          axis = Y_UNIT;
          v = new THREE.Vector3(0, this.fator1 * quantum, 0);
          break;
      }
      var jogoB = 36 + 48 * (3 - beaufort);
      if (this.banda < -Math.PI / jogoB) {
        this.fator1 = 1;
      }
      if (this.banda > Math.PI / jogoB) {
        this.fator1 = -1;
      }
      var qb = new THREE.Quaternion();
      qb.setFromEuler(v);
      this.mesh.quaternion.multiply(qb);
      this.banda += this.fator1 * quantum;
    };
    this.caturro = function(dt, id) {
      if (!this.mesh || beaufort === 0 || dt > 1)
        return;
      var axis;
      var v;
      var quantum = dt * beaufort / 180;
      switch (id) {
        case 'ccb':
          axis = X_UNIT;
          v = new THREE.Vector3(0, 0, this.fator2 * quantum);
          break;
        case 'fcg':
          axis = Y_UNIT;
          v = new THREE.Vector3(this.fator2 * quantum, 0, 0);
          break;
      }
      var jogoC = 72 + 36 * (3 - beaufort);
      if (this.trim < -Math.PI / jogoC) {
        this.fator2 = 1;
      }
      if (this.trim > Math.PI / jogoC) {
        this.fator2 = -1;
      }
      var qc = new THREE.Quaternion();
      qc.setFromEuler(v);
      this.mesh.quaternion.multiply(qc);
      this.trim += this.fator2 * quantum;
    };

  }

  var ap = new AlvoPai();

  function Escolta(x, y, z, id) {
    var th = this;
    this.loaded = false;
    this.prontoPara = false;
    this.loader = new THREE.OBJMTLLoader();
    this.id = id;
    this.obj = null;
    this.mtl = null;
    this.banda = 0;
    this.trim = 0;
    this.fator1 = 1;
    this.fator2 = 1;
    this.marcs = new Array();
    this.dists = new Array();
    this.load = function() {
      switch (th.id) {
        case 'fcg':
          th.obj = 'models/F46.obj';
          th.mtl = 'models/F46.mtl';
          break;
        case 'ccb':
          th.obj = 'models/V34.obj';
          th.mtl = 'models/V34.mtl';
          break;
      }
      th.loader.addEventListener('load', function(event) {
        th.mesh = event.content;
        th.mesh.useQuaternion = true;
        th.mesh.position.set(x, y, z);
        var q1 = new THREE.Quaternion();
        var q2 = new THREE.Quaternion();
        switch (th.id) {
          case 'fcg':
            q1.setFromAxisAngle(X_UNIT_NEG, Math.PI / 2);
            th.mesh.quaternion.multiply(q1);
            q2.setFromAxisAngle(Z_UNIT, -Math.PI / 2);
            th.mesh.quaternion.multiply(q2);
            break;
          case 'ccb':
            q1.setFromAxisAngle(Y_UNIT, -Math.PI / 2);
            th.mesh.quaternion.multiply(q1);
            break;
        }
        th.prontoPara = true;
        scene.add(th.mesh);
      });
      th.loader.load(th.obj, th.mtl);
    };
  }
  Escolta.prototype = ap;

  /* *****************Fim Alvos.js********************* */
  /* ************************************************** */



  /* ************************************************** */
  /* *****************Camadas.js*********************** */

  function overlayParent() {
    this.overlay;
    this.context;

    // Helpers
    /** Translates the origin to the top-left corner
     * and draws the same position on 2D canvas
     */
    this.worldToChart2D = function(pos, chartWidth, chartHeight) {
      //tirar multiplicadores do maxDist
      var xW = pos.x + maxDist / 3;
      var yW = pos.z + maxDist / 3;
      var xC = ((chartWidth - chartHeight) / 2) * (xW / (maxDist / 3 * 2));
      var yC = chartHeight * (yW / (maxDist / 3 * 2));
      var pos2D = new THREE.Vector2(xC + (chartWidth - chartHeight) / 2, yC);
      return pos2D;
    };



    this.create = function() {
      canvasContainer = document.createElement('div');
      canvasContainer.style.zIndex = '100';
      document.body.appendChild(canvasContainer);
      var overlayCanvas = document.createElement('canvas');
      overlayCanvas.style.position = 'absolute';
      var W = SCREEN_WIDTH;
      var H = SCREEN_HEIGHT;
      switch (this.type) {
        case "PERISCOPE":
          overlayCanvas.style.left = '0px';
          overlayCanvas.style.top = '0px';
          overlayCanvas.width = W;
          overlayCanvas.height = H;
          break;
        case "CHART":
          overlayCanvas.style.left = "75%";
          overlayCanvas.style.top = "70%";
          overlayCanvas.width = W / 4;
          overlayCanvas.height = H / 4;
          overlayCanvas.style.zIndex = 100;
      }
      canvasContainer.appendChild(overlayCanvas);
      this.overlay = overlayCanvas;
    };

    this.draw = function() {
      if (!this.overlay || avisando)
        return;
      this.context = this.overlay.getContext('2d');
      var x = window.innerWidth / 2;
      var y = window.innerHeight;
      switch (mode) {
        case aps.PERISCOPE:
          this.context.clearRect(0, 0, x * 2, y);
          var imgCorner = (SCREEN_WIDTH - SCREEN_HEIGHT) / 2;
          this.context.drawImage(circle, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
          this.context.font = "30pt Impact";
          this.context.fillStyle = "#ff0000"; // text color
          this.context.fillText(tBearing, x / 2, y - 10);
          this.context.fillText(rBearing, x * 1.5, y - 10);
          this.context.fillText(distance, x - 50, 50);
          this.context.fillText(centerMsg, x - 50, y / 2 - 10);
          this.context.font = "20pt Impact";
          this.context.fillStyle = "#000000";
          this.context.fillText(zoom, x / 3, 30);
          this.context.fillStyle = "#0000cc";
          this.context.fillText(stad, 5 * x / 4, 30);
          this.context.fillStyle = "#ffffff";
          var tempo = parlatorium[2] + "-> " + toClockLike(tempoIndiscreto);
          var v = "HSI -> " + toClockLike(ivh);
          var t1 = "OI-1 -> " + toClockLike(tgt1Time);
          var t2 = "OI-2 -> " + toClockLike(tgt2Time);
          this.context.fillText(tempo, 0, 30);
          this.context.fillText("Points: " + points, 0, 70);
          this.context.fillText(v, 0, y - 110);
          this.context.fillText(t1, 0, y - 70);
          this.context.fillText(t2, 0, y - 30);
          this.context.beginPath();
          this.context.moveTo(x, 0);
          this.context.lineTo(x, y);
          this.context.moveTo(0, y / 2);
          this.context.lineTo(x * 2, y / 2);
          for (var i = 1; i < 10; i++) {
            this.context.moveTo(x - 160, i * y / 10);
            this.context.lineTo(x - 110, i * y / 10);
          }
          this.context.stroke();
          this.context.closePath();
          break;
        case aps.NAVIGATION:
          this.context.drawImage(carta, 0, 0, x * 2, y);
          this.context.drawImage(obs2, x * 2 - 140, y - 140, 100, 100);
          this.context.drawImage(obs1, x * 2 - 280, y - 140, 100, 100);
          this.context.drawImage(varHor, x * 2 - 420, y - 140, 100, 100);
          var tempo = parlatorium[2] + "-> " + toClockLike(tempoIndiscreto);
          var v = "IVH -> " + toClockLike(ivh);
          var t1 = "OI-1 -> " + toClockLike(tgt1Time);
          var t2 = "OI-2 -> " + toClockLike(tgt2Time);
          this.context.font = "20pt Impact";
          this.context.fillStyle = "#ffffff";
          this.context.fillText(tempo, 0, 30);
          this.context.fillText("Points: " + points, 0, 70);
          this.context.fillText(v, 0, y - 110);
          this.context.fillText(t1, 0, y - 70);
          this.context.fillText(t2, 0, y - 30);
          var subPosition = this.worldToChart2D(subPos, x * 2, y);
          this.context.drawImage(subIco, subPosition.x - 16, subPosition.y - 12, 32, 24);
          //for ( t in targetArray){
          //if (!t.prontoPara)continue;
          if (fragPos) {
            var tgt1Pos = this.worldToChart2D(fragPos, x * 2, y);
            this.context.drawImage(hvuIco, tgt1Pos.x - 30, tgt1Pos.y - 15, 60, 30);
          }
          if (corvPos) {
            var tgt2Pos = this.worldToChart2D(corvPos, x * 2, y);
            this.context.drawImage(fragIco, tgt2Pos.x - 30, tgt2Pos.y - 15, 60, 30);
          }
          break;
        case aps.INFO:
          this.clear();
          this.context.drawImage(infoImg, 0, 0, x * 2, y);
          break;
        case aps.LOADING:
          this.clear();
          this.context.drawImage(loadImg, 0, 0, x * 2, y);
          break;
        case aps.TUTOR:
          this.clear();
          this.context.drawImage(tutor[tutorIndex], 0, 0, x * 2, y);
          if (tutorIndex < 2)
            this.context.drawImage(next, x * 2 - 140, y - 140, 100, 100);
          if (tutorIndex > 0)
            this.context.drawImage(previous, 40, y - 140, 100, 100);
          break;
        case aps.GAME_OVER:
          this.clear();
          this.context.drawImage(gameOver, 0, 0, x * 2, y);
          break;
      }
      this.context.restore();

    };

    this.avisa = function(str, t) {
      avisando = true;
      var cont = 0;
      var x = window.innerWidth / 2 - str.length * 10;
      var y = window.innerHeight / 2 - 30;
      this.context.font = "40px Impact";
      this.context.fillStyle = "#ff0000";
      this.context.fillText(str, x, y);
      setInterval(this.limpAviso, t * 1000);
    };
    this.limpAviso = function() {
      avisando = false;
    };

    this.clear = function() {
      this.context.clearRect(0, 0, this.overlay.width,
              this.overlay.height);
    };

    this.resize = function(left, top, wDiv, hDiv) {
      this.overlay.style.left = left;
      this.overlay.style.top = top;
      this.overlay.width = this.canvas.clientWidth / wDiv;
      this.overlay.height = this.canvas.clientWidth / hDiv;
      this.overlay.style.zIndex = 1;
    };
  }
  var ol = new overlayParent();
  var Overlay = function(mainCanvas, type) {
    this.canvas = mainCanvas;
    this.type = type;
  };
  Overlay.prototype = ol;


  /* ***********Fim Camadas.js************************* */
  /* ************************************************** */



  /* ************************************************** */
  /* ***********Auxiliares.js************************* */


  /**
   * @author ricardoSBastos
   *
   * Given an Object3D this function calculates the course based 
   * in it's yaw ( Basically written to compute
   * the bearing of periscope view - won't work for quaternions)
   */
  var computeBearing = function(objeto) {
    if (!objeto)
      return;

    // Returns the angle rounded to 2 decimals
    this.roundToBearing = function(angle) {
      return Math.round(10.0 * angle) / 10;
    };

    // formats the bearing to the naval usage of three digitis
    this.to3Digits = function(angle) {
      if (angle === 360)
        return "000.0";
      var decimal = "";
      if (angle === Math.round(angle))
        decimal = ".0";
      if (angle < 10) {
        return "00" + angle + decimal;
      }
      else if (angle < 100) {
        return "0" + angle + decimal;
      }
      else {
        return angle + decimal;
      }
    };

    // returns the inverse of a bearing in naval format
    this.reciproca = function(angle) {
      if (angle >= 180) {
        return roundToBearing(angle - 180);
      }
      else {
        return roundToBearing(angle + 180);
      }
    };

    // returns the bearing relatively to a ship's bow
    this.relativa = function(marcV, rumo) {
      if (marcV > rumo)
        return roundToBearing(marcV - rumo);
      else
        return roundToBearing(360 - rumo + marcV);
    };

    var angle = -roundToBearing(THREE.Math.radToDeg(objeto.rotation.y));
    if (angle > 360)
      angle = roundToBearing(angle %= 360.0);
    if (angle < 0) {
      if (angle < -360) {
        angle = roundToBearing((angle %= 360.0) + 360);
      }
      else {
        angle = roundToBearing(angle += 360);
      }
    }
    tBearing = to3Digits(angle);
    rBearing = to3Digits(relativa(angle, sbHead));
  };

  var toClockLike = function(t) {
    tString = "";
    var minutos = Math.floor(t / 60);
    if (minutos < 10)
      minutos = "0" + minutos;
    var segundos = Math.floor(t % 60);
    if (segundos < 10)
      segundos = "0" + segundos;
    tString += minutos + " : " + segundos;
    return tString;
  };

  function setHeight() {
    tgtHeight = Number(prompt(parlatorium[0], "40.0"));
    computeDistance(grauEstadimetro);
  }

  var computeIO = function(marc, dist) {
    var vdist = Math.round(Number(dist / 100)) * 100;
    var vmarc = Number(marc);
    var setor;
    var io;
    if (vmarc >= 300 || vmarc <= 60)
      setor = 1;
    if ((vmarc < 300 && vmarc >= 270) || (vmarc > 60 && vmarc <= 90))
      setor = 2;
    if ((vmarc < 270 && vmarc >= 240) || (vmarc > 90 && vmarc <= 120))
      setor = 3;
    if (vmarc < 240 || vmarc > 120)
      setor = 4;
    switch (setor) {
      case 1:
        io = (vdist - 1200) / 100 * 5;
        console.log(io);
        break;
      case 2:
        io = (vdist - 1100) / 100 * 5;
        console.log(io);
        break;
      case 3:
        io = (vdist - 1000) / 100 * 6;
        console.log(io);
        break;
      case 4:
        io = (vdist - 900) / 100 * 6;
        console.log(io);
        break;
    }
    if (io < 0)
      return 0;
    else if (io < 18) {
      alert("Contact is too close - keep looking and measuring distance until it is at a safe distance.");
    }
    else {
      return io;
    }
  };

  function computeTimes(dt) {
    if (dt > 1)
      return; // don't know why, but it happens sometimes!!
    if (mode == aps.PERISCOPE)
      tempoIndiscreto += deltaT;
    simTime += deltaT;
    if (varredura) {
      ivh += deltaT;
      tgt1Time += deltaT;
      tgt2Time += deltaT;
    }
    if (ivh >= 180)
      gameOverBaby();
    if (fazOMovimento === "obs1"
            && tgt1Time > 15) {
      alert("You need to improve your movements, you took more than 15 seconds to observe the contact!!");
      points -= 10;
      mode = aps.NAVIGATION;
      fazOMovimento = null;
    }
    if (fazOMovimento === "obs2"
            && tgt2Time > 18) {
      alert("You took more than 18 seconds to observe the contact!! Less 10 points...");
      points -= 10;
      mode = aps.NAVIGATION;
      fazOMovimento = null;
    }
    if (fazOMovimento === "vh"
            && ivh > 35) {
      alert("You need to improve your movements, you're supposed to take less than 35 seconds to check tactical situation around you");
      points -= 10;
      mode = aps.NAVIGATION;
      fazOMovimento = null;
    }
    if (points <= 0 || ivh >= 180 || tgt1Time >= io1 || tgt2Time >= io2)
      gameOverBaby();
    if (corvPos) {
      if (corvPos.z > 0)
        unveil();
    }
  }

  function unveil() {
    window.location = "unveil.html";
  }

  var computeMarcDist = function(tgt) {
    if (!tgt.mesh)
      return;
    var pos = tgt.mesh.position;
    var pos2 = new THREE.Vector2(pos.x - subPos.x, pos.z - subPos.z);
    var len = Math.sqrt(pos2.x * pos2.x + pos2.y * pos2.y);
    var cos = Math.abs(pos2.x / len);
    var sin = pos2.z / len;
    var setor;
    if (cos > 0.5) {
      sin > 0 ? setor = 2 : setor = 3;
    } else {
      sin > 0 ? setor = 1 : setor = 4;
    }

  };



  var computeDistance = function(altura) {
    if (altura <= 0)
      return;

    var distancia = tgtHeight / 100 * 126 / altura;
    distancia = Math.round(distancia * 10) / 10;
    console.log(distancia);
    var decimal = "";
    if (Math.round(distancia) == distancia) {
      decimal += ".0";
    }

    if (distancia > 20000.0) {
      distance = "20000.0";
      return;
    }
    if (distancia < 10) {
      distance = "0000" + distancia + decimal;
      return;
    } else
    if (distancia < 100) {
      distance = "000" + distancia + decimal;
      return;
    } else
    if (distancia < 1000) {
      distance = "00" + distancia + decimal;
      return;
    } else
    if (distancia < 10000) {
      distance = "0" + distancia + decimal;
      return;
    }

  };


  function onWindowResize() {
    if (!(camera && renderer))
      return;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }


  function angleBetweenQuats(qBefore, qAfter) {
    q1 = new THREE.Quaternion();
    q1.copy(qBefore);
    q1.inverse();
    q1.multiply(qAfter);
    var halfTheta = Math.acos(q1.w);
    return 2 * halfTheta;
  }

  function lookTowards(fromObject, toPosition, dTheta) {
    var quat0 = new THREE.Quaternion();
    quat0.setFromRotationMatrix(fromObject.matrix);
    var eye = fromObject.position;
    var center = toPosition;
    var up = new THREE.Vector3(0, 1, 0);
    var mat = new THREE.Matrix4();
    mat.lookAt(center, eye, up);
    var quat1 = new THREE.Quaternion();
    quat1.setFromRotationMatrix(mat);
    var deltaTheta = angleBetweenQuats(quat0, quat1);
    var frac = dTheta / deltaTheta;
    if (frac > 1)
      frac = 1;
    fromObject.quaternion.slerp(quat1, frac);
  }

  function doObs1() {
    if (!varredura) {
      alert("Your first movement must always be an All Around Search, to figure out the tactical situation.");
      return;
    }
    tgt1Time = 0;
    mode = aps.PERISCOPE;
    tgt1 = true;
    tgt2 = false;
    fazOMovimento = "obs1";
    if (primatgt1 && primatgt2) {
      alert("You have up to 18 seconds to obtain the target data (bearing and distance).  You need to know how to use the stadimeter. In case of doubt press '1'.");
      alert("Don't forget to set target's height pressing 's', and to press 'c' to send the data to weapons system, lower the periscope and send data to weapons system.");
    }
    if (primatgt1)
      primatgt1 = false;
  }
  function doObs2() {
    if (!varredura) {
      alert("Your first movement must always be an All Around Search, to figure out the tactical situation.");
      return;
    }
    tgt2Time = 0;
    mode = aps.PERISCOPE;
    tgt2 = true;
    tgt1 = false;
    fazOMovimento = "obs2";
    if (primatgt1 && primatgt2) {
      alert("You have up to 18 seconds to obtain the target data (bearing and distance).  You need to know how to use the stadimeter. In case of doubt press '1'.");
      alert("Don't forget to set target's height pressing 's', and to press 'c' to send the data to weapons system, lower the periscope and send data to weapons system.");
    }
    if (primatgt2)
      primatgt2 = false;
  }
  function doVH() {
    fazOMovimento = "vh";
    if (!varredura) {
      alert("You have up to 35 seconds to turn the periscope 360� and look for new targets. You might need to accelerate your turning by holding down 'Shift' key. Use zoom = 1.5x, and try to set elevation for 1/3 of sea and 2/3 of sky.");
      varredura = true;
      mode = aps.PERISCOPE;
      perOverlay.draw();
      alert("Make sure to perform another All Around Search before HSI = 03:00. As soon as you finish the turn, press '2' to lower the periscope and go back to Navigation Mode.");
    }
    mode = aps.PERISCOPE;
    ivh = 0;
  }

  function gameOverBaby() {
    window.location = "gameOver.html";
  }

  /* ***********Fim Auxiliares.js********************** */
  /* ************************************************** */


  /* ****************Eventos.js************************ */
  /* ************************************************** */

  function onKeyDown(evt) {
    switch (evt.keyCode) {
      case 16: //'shift'
        periRotVeloc = 2.5;
        estadiVeloc = 0.01;
        break;
      case 17: //'ctrl'
        if (mode !== aps.PERISCOPE)
          return;
        if (modoEstadimetro) {
          modoEstadimetro = false;
          telaEstadimetro.visible = false;
          stad = "";
        }
        else {
          modoEstadimetro = true;
          if (tgtHeight === 0)
            alert("You must set the target's height (press 's' to set)");
          telaEstadimetro.visible = true;
          stad = parlatorium[1];
        }
        break;
      case 39: // 'right arrow' turns periscope right
        if (mode !== aps.PERISCOPE)
          return;
        event.preventDefault();
        turnRight = true;
        break;
      case 37: // 'left arrow' turns periscope left
        if (mode !== aps.PERISCOPE)
          return;
        event.preventDefault();
        turnLeft = true;
        break;
      case 38: // 'up arrow' increase periscope elevation
        if (mode !== aps.PERISCOPE)
          return;
        event.preventDefault();
        turnUp = true;
        break;
      case 40: // 'down arrow' decrease periscope elevation
        if (mode !== aps.PERISCOPE)
          return;
        event.preventDefault();
        turnDown = true;
        break;
      case 49: // '1' toggle to mode Info
        if (mode === aps.INFO) {
          mode = lastMode;
          paused = false;
          centerMsg = "";
        } else {
          lastMode = mode;
          mode = aps.INFO;
          perOverlay.draw();
          paused = true;

        }
        break;
      case 50: // '2' toggle to mode Navigation
        mode = aps.NAVIGATION;
        fazOMovimento = null;
        break;
      case 51: // '3' toggle to mode Tutor
        if (mode === aps.TUTOR) {
          mode = lastMode;
          paused = false;
          centerMsg = "";
        } else {
          lastMode = mode;
          mode = aps.TUTOR;
          perOverlay.draw();
          paused = true;

        }
        break;

      case 67: // 'c' compute bearing & distance
        if (mode !== aps.PERISCOPE)
          return;
        if (tgtHeight == 0) {
          alert("You need to compute the target's data!! Use the stadimeter ('CTRL')");
          return;
        }
        if (tgt1) {
          io1 = computeIO(tBearing, distance);
          alert("Make sure to observe the same contact again before OI-1 (Observation Interval) is equal to " + toClockLike(io1));
          mode = aps.NAVIGATION;
          fazOMovimento = null;
        } else if (tgt2) {
          io2 = computeIO(tBearing, distance);
          alert("Make sure to observe the same contact again before OI-1 (Observation Interval) is equal to " + toClockLike(io2));
          mode = aps.NAVIGATION;
          fazOMovimento = null;
        } else {
          alert("You are not supposed to stop your scan to observe any contact. You must choose a target to observe from Navigation Mode!!");
        }

        break;
      case 77: // 'm' on/off music
        if (music) {
          chan1.volume = 0.0;
          music = false;
        } else {
          chan1.volume = 0.3;
          music = true;
        }
        break;
      case 80: // 'p' pause
        if (paused) {
          paused = false;
          centerMsg = "";
        }
        else {
          centerMsg = "PAUSED";
          perOverlay.draw();
          paused = true;
        }
        break;
      case 83: // 's' set target height for stadimeter
        setHeight();
        break;
      case 90: // 'z' periscope's zoom
        if (mode !== aps.PERISCOPE)
          return;
        switch (fov) {
          case 40:
            fov = 20;
            camera1.fov = fov;
            camera1.updateProjectionMatrix();
            telaEstadimetro.scale = new THREE.Vector3(0.5, 0.5, 0.5);
            zoom = "6.0x";
            break;
          case 20:
            fov = 5;
            camera1.fov = fov;
            camera1.updateProjectionMatrix();
            telaEstadimetro.scale = new THREE.Vector3(0.125, 0.125, 0.125);
            zoom = "12.0x";
            break;
          case 5:
            fov = 40;
            camera1.fov = fov;
            camera1.updateProjectionMatrix();
            telaEstadimetro.scale = new THREE.Vector3(1, 1, 1);
            zoom = "1.5x";
            break;
        }
    }
  }

  function onKeyUp(evt) {
    switch (evt.keyCode) {
      case 16: //'shift'
        periRotVeloc = 5;
        estadiVeloc = 0.001;
        break;
      case 39: // 'right arrow' turns periscope right
        event.preventDefault();
        turnRight = false;
        break;
      case 37: // 'left arrow' turns periscope right
        event.preventDefault();
        turnLeft = false;
        break;
      case 38:
        event.preventDefault();
        turnUp = false;
        break;
      case 40:
        event.preventDefault();
        turnDown = false;
        break;
    }
  }



  function periscopeUpdate(deltaT) {
    if (!periscope)
      return;
    if (!(turnRight || turnDown || turnUp || turnLeft))
      return;
    if (turnRight) {
      periscope.rotation.y -= deltaT / periRotVeloc;
      computeBearing(periscope);
    }
    else if (turnLeft) {
      periscope.rotation.y += deltaT / periRotVeloc;
      computeBearing(periscope);
    }
    if (modoEstadimetro && turnUp &&
            telaEstadimetro.position.y < 0.4) {
      telaEstadimetro.position.y += estadiVeloc;
      grauEstadimetro += estadiVeloc;
      computeDistance(grauEstadimetro);
    }
    else if (modoEstadimetro && turnDown &&
            telaEstadimetro.position.y > 0) {
      telaEstadimetro.position.y -= estadiVeloc;
      grauEstadimetro -= estadiVeloc;
      computeDistance(grauEstadimetro);
    }
    else if (turnUp && !modoEstadimetro) {
      quat.setFromAxisAngle(X_UNIT, deltaT / 5);
      if (elevation < Math.PI / 2) {
        elevation += deltaT / 5;
        camera1.quaternion.multiply(quat);
      }
    }
    else if (turnDown && !modoEstadimetro) {
      quat.setFromAxisAngle(X_UNIT_NEG, deltaT / 5);
      if (elevation > -Math.PI / 36) {
        elevation -= deltaT / 5;
        camera1.quaternion.multiply(quat);
      }
    }
  }

  function onMouseDown(evt) {
    if (!(mode == aps.NAVIGATION || mode == aps.TUTOR))
      return;
    var mouseX = evt.pageX;
    var mouseY = evt.pageY;
    var x = window.innerWidth;
    var y = window.innerHeight;
    if (mode == aps.NAVIGATION) {
      mouseX = evt.pageX;
      mouseY = evt.pageY;
      if ((mouseY >= y - 140) && (mouseY <= y - 40)) {
        if ((mouseX >= x - 140) && (mouseX <= x - 40))
          doObs2();
        if ((mouseX >= x - 280) && (mouseX <= x - 180))
          doObs1();
        if ((mouseX >= x - 420) && (mouseX <= x - 320))
          doVH();
      }
    }
    if (mode == aps.TUTOR) {
      if ((mouseY >= y - 140) && (mouseY <= y - 40)) {
        if ((mouseX >= x - 140) && (mouseX <= x - 40)
                && tutorIndex < 2) {
          tutorIndex += 1;
          perOverlay.draw();
        }

        if ((mouseX >= 40) && (mouseX <= 140)
                && tutorIndex > 0) {
          tutorIndex -= 1;
          perOverlay.draw();
        }
      }
    }
  }

  /* **************Fim Eventos.js********************** */
  /* ************************************************** */
  window.onload = function() {

    initSimulation()
    initEnvironment()

    animate();
  }

})();

    </script>
  </body>
</html>
